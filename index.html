<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>eecs493proj</title>
    <link href="css/default.css" rel="stylesheet" />
</head>
<body>

    <button id="delete">toggle delete</button>
    <select id="color">
        <!--<option value="stone">stone</option>-->
        <option value="red">red</option>
        <option value="orange">orange</option>
        <option value="yellow">yellow</option>
        <option value="green">green</option>
        <option value="blue">blue</option>
        <option value="purple">purple</option>
        <option value="white">white</option>
        <option value="black">black</option>
        <option value="chocolate">brown</option>
        <option value="gray">gray</option>
    </select>
    <select id="geo" onchange="SwitchGeo(this.value)">
        <option value="square">square</option>
        <option value="rectangle">rectangle</option>
        <option value="quarterBlock">quarter-block</option>
        <option value="cylinder">cylinder</option>
        <option value="pyramid">pyramid</option>
        <option value="half pyramid">half pyramid</option>
    </select>
    <input type="radio" id="mouseControls" name="control" checked/>
    <label for="mouseControls">Mouse</label>
    <input type="radio" id="keyboardControls" name="control"/>
    <label for="mouseControls">Keyboard</label>
    <div id="game">
        <script src="js/three.js"></script>
        <script src="js/OrbitControls.js"></script>
        <!--<script src="js/DragControls.js"></script> -->
        <script>
            var scene = new THREE.Scene();
            var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 500);
            var renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.shadowMap.enabled = true;

            renderer.setClearColor(0xddeeff);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            var objects = []; //array of all objects on map   THIS IS WHAT WE LOAD AND STORE

            var raycaster = new THREE.Raycaster(); //used to detect where mouse is pointing
            var mouse = new THREE.Vector2(); //holds location of mouse on screen
            var deletion = false; //delete button selected

            //cube impl
            var globe_geometry = new THREE.BoxGeometry(20, 20, 20);
            var globe_material = new THREE.MeshLambertMaterial({ color: 0x40ff8f });
            //var stone_texture = new THREE.TextureLoader().load('add later');

            camera.position.set(100, 100, 200);
            camera.lookAt(new THREE.Vector3(0, 0, 0));

            //line impl
            /*var lineGeo = new THREE.Geometry();
            var lineMaterial = new THREE.LineBasicMaterial({ color: 0x0000ff });
            lineGeo.vertices.push(new THREE.Vector3(-10, 0, 0));
            lineGeo.vertices.push(new THREE.Vector3(0, 10, 0));
            lineGeo.vertices.push(new THREE.Vector3(10, 0, 0));
            lineGeo.vertices.push(new THREE.Vector3(0, -10, 0));
            lineGeo.vertices.push(new THREE.Vector3(-10, 0, 0));
            var line = new THREE.Line(lineGeo, lineMaterial);*/

            var gridSize = 200;
            var gridDivs = 20;
            var grid = new THREE.GridHelper(gridSize, gridDivs);

            //temporary transparent block from three.js
            var rollOverGeo = new THREE.BoxGeometry(20, 20, 20);
            rollOverMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, opacity: 0.5, transparent: true });
            rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
            rollOverMesh.position.addScalar(10);
            scene.add(rollOverMesh);

            //scene.add(cube);
            //scene.add(line);
            scene.add(grid);

            var square = new THREE.BoxGeometry(20, 20, 20);
            var rectangle = new THREE.BoxGeometry(20, 20, 40);
            var quarterBlock = new THREE.BoxGeometry(10, 20, 10);
            var pyramid = new THREE.CylinderGeometry(0, 10, 20, 4, false);
            var cylinder = new THREE.CylinderGeometry(10, 10, 20, 100, false);

            var halfPyramid = new THREE.Geometry();
            halfPyramid.vertices = [
                new THREE.Vector3(0, 0, 0),    //0 
                new THREE.Vector3(20, 0, 0),   //1
                new THREE.Vector3(20, 0, 20),   //2
                new THREE.Vector3(0, 0, 20),  //3
                new THREE.Vector3(20, 20, 0),  //4 
                new THREE.Vector3(20, 20, 20)  //5
            ];
            var face = new THREE.Face3(0, 1, 2);
            halfPyramid.faces.push(face);
            face = new THREE.Face3(0, 2, 3);
            halfPyramid.faces.push(face);
            face = new THREE.Face3(0, 4, 5);
            halfPyramid.faces.push(face);
            face = new THREE.Face3(0, 3, 5);
            halfPyramid.faces.push(face);
            face = new THREE.Face3(0, 1, 4);
            halfPyramid.faces.push(face);
            face = new THREE.Face3(3, 2, 5);
            halfPyramid.faces.push(face);
            face = new THREE.Face3(1, 2, 4);
            halfPyramid.faces.push(face);
            face = new THREE.Face3(2, 4, 5);
            halfPyramid.faces.push(face);

            var geometry = new THREE.PlaneBufferGeometry(200, 200);
            geometry.rotateX(- Math.PI / 2);
            plane = new THREE.Mesh(geometry, new THREE.MeshLambertMaterial({ visible: true }));
            plane.receiveShadow = true;
            scene.add(plane);
            objects.push(plane);

            var ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);

            var light = new THREE.SpotLight(0xffffff, 1.6);
            light.position.copy(camera.position);
            light.shadowCameraVisible = true;
            scene.add(light);

            var dropColor = document.getElementById('color');
            var dropGeo = document.getElementById('geo');



            //Javascript event listeners
            var deleteEvent = document.getElementById("delete");
            deleteEvent.addEventListener('mouseup', function () {
                deletion = !deletion;
                console.log("delete hit!");
                if (deletion) scene.remove(rollOverMesh);
                else scene.add(rollOverMesh);
                render();
            }, false);

            var game = document.getElementById('game');
            document.addEventListener('mousemove', onDocumentMouseMove, false);
            document.addEventListener('mousedown', onDocumentMouseDown, false);
            window.addEventListener('keydown', arrowKeys, true);
            window.addEventListener('keyup', enterKey, false);
            window.addEventListener('resize', onWindowResize, false);
            renderer.render(scene, camera);
            //var testObj;

            var mouseCont = document.getElementById('mouseControls');
            var keyCont = document.getElementById('keyboardControls');

            function onDocumentMouseMove(event) {  //taken from threejs.org
                if (mouseCont.checked) {
                    event.preventDefault();
                    mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
                    raycaster.setFromCamera(mouse, camera); //generates ray from camera passing through mouse location
                    var intersects = raycaster.intersectObjects(objects);
                    //console.log(intersects);
                    if (intersects.length > 0 && !deletion) {
                        var intersect = intersects[0];
                        rollOverMesh.position.copy(intersect.point).add(intersect.face.normal);
                        rollOverMesh.position.divideScalar(5).floor().multiplyScalar(5).addScalar(10);
                    }
                    render();
                }
            }

            function onDocumentMouseDown(event) {
                //event.preventDefault();
                if (mouseCont.checked) {
                    mouse.set((event.clientX / window.innerWidth) * 2 - 1, - (event.clientY / window.innerHeight) * 2 + 1);
                    raycaster.setFromCamera(mouse, camera);
                    var intersects = raycaster.intersectObjects(objects);
                    console.log(intersects);
                    if (intersects.length > 0) {
                        var intersect = intersects[0];
                        //testObj = intersect.object;
                        //console.log("before delete: " + testObj.parameters);
                        if (deletion) {
                            if (intersect.object != plane) {
                                scene.remove(intersect.object);
                                objects.splice(objects.indexOf(intersect.object), 1);
                                //delete intersect.object;
                                //console.log("after delete: " + testObj.parameters);
                                //console.log(objects);
                            }
                        }
                        else {
                            cur_geo = globe_geometry;
                            /*if (dropColor.value == "stone") {
                                cur_color = new THREE.MeshLambertMaterial({ map: stone_texture })
                            }*/
                            var cur_color = new THREE.MeshLambertMaterial({ color: dropColor.value });
                            block = new THREE.Mesh(cur_geo, cur_color);
                            block.castShadow = true;
                            block.receiveShadow = true;
                            block.position.copy(intersect.point).add(intersect.face.normal);
                            block.position.divideScalar(5).floor().multiplyScalar(5).addScalar(10);
                            scene.add(block);
                            objects.push(block);
                            console.log("dropped block!");
                        }
                    }
                    render();
                }
            }

            function arrowKeys(event) {
                if (keyCont.checked) {
                    if (event.keyCode == 37) {  //left arrow
                        event.preventDefault();
                        event.stopPropagation();
                        rollOverMesh.translateX(-5);
                    }
                    else if (event.keyCode == 38) { //up arrow
                        event.preventDefault();
                        event.stopPropagation();
                        rollOverMesh.translateZ(-5);
                    }
                    else if (event.keyCode == 39) { //right arrow
                        event.preventDefault();
                        event.stopPropagation();
                        rollOverMesh.translateX(5);
                    }
                    else if (event.keyCode == 40) { //down arrow
                        event.preventDefault();
                        event.stopPropagation();
                        rollOverMesh.translateZ(5);

                    }
                }
                render();
                return false;
            }

            function enterKey(event) {
                if (keyCont.checked) {
                    event.preventDefault();
                    if (event.keyCode == 13) {
                        var keyGeo = globe_geometry;
                        /*if (dropColor.value == "stone") {
                            cur_color = new THREE.MeshLambertMaterial({ map: stone_texture })
                        }*/
                        var keyColor = new THREE.MeshLambertMaterial({ color: dropColor.value });
                        block = new THREE.Mesh(keyGeo, keyColor);
                        block.castShadow = true;
                        block.receiveShadow = true;
                        block.position.setFromMatrixPosition(rollOverMesh.matrixWorld)
                        //block.position.divideScalar(5).floor().multiplyScalar(5).addScalar(10);
                        scene.add(block);
                        objects.push(block);
                        console.log("dropped block!");
                        console.log("enter hit!");
                    }
                }
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            function SwitchGeo(val) {
                if (val == "square") {
                    globe_geometry = square;
                    position = rollOverMesh.position;
                    scene.remove(rollOverMesh);
                    delete rollOverMesh;
                    rollOverGeo = square;
                    rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
                    rollOverMesh.position.set(position);
                    scene.add(rollOverMesh);
                }
                else if (val == "rectangle") {
                    globe_geometry = rectangle;
                    position = rollOverMesh.position;
                    scene.remove(rollOverMesh);
                    delete rollOverMesh;
                    rollOverGeo = rectangle;
                    rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
                    rollOverMesh.position.set(position);
                    scene.add(rollOverMesh);
                }
                else if (val == "quarterBlock") {
                    globe_geometry = quarterBlock;
                    position = rollOverMesh.position;
                    scene.remove(rollOverMesh);
                    delete rollOverMesh;
                    rollOverGeo = quarterBlock;
                    rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
                    rollOverMesh.position.set(position);
                    scene.add(rollOverMesh);
                }
                
                else if (val == "pyramid") {
                    globe_geometry = pyramid;
                    position = rollOverMesh.position;
                    scene.remove(rollOverMesh);
                    delete rollOverMesh;
                    rollOverGeo = pyramid;
                    rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
                    rollOverMesh.position.set(position);
                    scene.add(rollOverMesh);
                }
                else if (val == "half pyramid") {
                    globe_geometry = halfPyramid;
                    position = rollOverMesh.position;
                    scene.remove(rollOverMesh);
                    delete rollOverMesh;
                    rollOverGeo = halfPyramid;
                    console.log(halfPyramid);
                    rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
                    rollOverMesh.position.set(position);
                    scene.add(rollOverMesh);
                }
                else if (val == "cylinder") {
                    globe_geometry = cylinder;
                    position = rollOverMesh.position;
                    scene.remove(rollOverMesh);
                    delete rollOverMesh;
                    rollOverGeo = cylinder;
                    rollOverMesh = new THREE.Mesh(rollOverGeo, rollOverMaterial);
                    rollOverMesh.position.set(position);
                    scene.add(rollOverMesh);
                }
            }

            function render() {
                renderer.render(scene, camera);
            }

            //allows camera movement
            var controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.addEventListener('change', function () { renderer.render(scene, camera); });
        </script>
    </div>
</body>
</html>
